# Bulk Loading

기존재하는 데이터를 redis로 들여올 때 사용하는 방법

- bulk loading을 해야할 때에는 다음의 이유들로 일반 클라이언트를 사용하지 않는것이 좋다.
  1. 커맨드 하나를 수행할때마다 RTT가 추가된다. 파이프라이닝을 사용할 수도 있겠지만, bulk loading할 때에는 많은 데이터들이 빠르게 잘 입력되고 있는지 insert와 동시에 확인되어야 한다(read replies).
  2. 대부분의 클라이언트는 non-blocking I/O를 지원하지 않으며, 처리량(throughput)을 최대화하는 방향으로 replies를 효율적으로 파싱하도록 구현되어있지 않다.

따라서 일반적으로 Redis에 대량의 데이터를 들여오기 위해서는 Redis Protocol을 포함하는 raw format의 text file을 생성하는 것이 낫다.



## How-to

- 2.6 미만의 버전에서는 nc(netcat)를 이용하여 Redis 머신에 직접 txt io를 feeding하는 방식으로 수행한다. 다만 이 방식은언제 모든 데이터가 전송될지, 또 redis가 해당 데이터를 에러없이 잘 입력했는지 확인할 수 없기 때문에 권장되지 않는다.

- 2.6 이상의 버전에서는 redis-cli에 내장된 `pipe mode`를 사용한다.

  - ```bash
    cat data.txt | redis-cli --pipe
    ```

  - 이 방식은 인스턴스에서 받은 오류를 stdout으로 리다이렉팅 해준다.



### Redis Protocol 생성하기

디테일은 [링크된 문서](https://redis.io/topics/protocol)를 참고한다.

전체 형태는 다음과 같은 일관적인 패턴을 따른다.

```xml
*<args><cr><lf>
$<len><cr><lf>
<arg0><cr><lf>
<arg1><cr><lf>
...
<argN><cr><lf>
```

- `<cr>` 은 \r을, `<lf>`는 \n을 의미한다.



적당한 언어를 이용하여 이 형식에 맞는 문자열 txt를 생성한 뒤 이를 redis-cli로 전달하면 된다.



## How the pipe mode works

- redis-cli --pipe는 서버에 최대한 데이터를 빨리 보내고, 동시에 읽을 수 있는 응답 데이터를 파싱 시도한다.
- stdin에 더 입력된 데이터가 없다면 서버에서 클라이언트로 `ECHO` 커맨드로 랜덤한 20바이트의 string을 보내는데, 클라이언트에서는 20바이트의 랜덤 문자열을 reply로 받았을때 마지막 command까지 모두 보낸것인지 확인해주어야한다.
- 최종적으로 모든 command를 전달했으면, 마지막으로 전달받은 20바이트의 랜덤 문자열을 다시 반환하여 완료되었음을 알린다.



# Distributed Locks

분산락은 다중 프로세스가 mutually exclusive way로 리소스를 공유할 때 자주 사용되는 패턴이다. Redis로 분산락 매니저(DLM, Distributed Lock Manager)를 구현한 라이브러리나 아티클은 많지만, 각기 다른 방식으로 구현된 편이고, 조금 더 복잡한 방식으로 구현했을 때 얻을 수 있는 장점들을 포기하고 심플하게 구현된 경우가 많다.



이에 Redis는 공식적으로 **`Redlock`**이라고 불리는 알고리즘을 제안하여 이를 사용하는 것을 추천하고 있다.

- Redlock의 구현체는 언어별로 여럿 있는 경우가 있으니 참고하자.



## Design

### Guarantees

분산락을 효율적으로 이용하기 위해 보장되어야하는 최소한의 세가지 성질이 있다.

1. 안전성 : 상호 배제(Mutual Exclusion)
2. 생존성 A : 데드락에서 자유로울 것. 리소스를 점유한 클라이언트가 터지거나 쪼개지더라도, 데드락이 발생하지 않고 lock을 획득할 수 있어야 한다.
3. 생존성 B : 내결함성(Fault tolerance). 대부분의 레디스 노드가 떠있는 한 클라이언트는 lock을 획득하고 풀어줄 수 있어야 한다.



### Failover 기반 전략만으로는 충분하지 않다.

대부분의 레디스 기반 분산락 라이브러리들이 가지는 문제점을 살펴보자. 이들 구현체는 락을 획득하고 해제하는 과정을 TTL을 가진 키를 생성하고 삭제하는 방식으로 구현한다.

- 락을 획득 : TTL을 가진 키 생성
- 락을 해제 : 키 삭제
- 해제하지 않는다면 TTL에 따라 만료됨으로써 락을 해제(생존성 A 원칙)

이 방식은 다음과 같은 문제를 가진다.

1. 레디스 마스터 노드가 다운되었다면 키를 획득하고 해제할 수 없다. -> *SPoF 문제*
2. replica를 승격시켜 마스터 노드를 대신한다.
   - 이 때 replica는 기존 마스터 노드의 asynchronous한 복제본이다.
   - 따라서 race condition이 발생할수 있다. 
     - 클라이언트 A가 마스터 노드에서 락을 획득한 뒤, 레플리카로 이 락에 대한 쓰기 요청이 복제되기 전에 마스터가 터져서 레플리카가 승격된다.
     - 클라이언트 B는 락이 없는 마스터노드에 요청을 할 수 있으므로, 해당 락을 획득할 수 있다. -> *안전성 원칙(Mutual Exclusion) 위반*

이러한 경우는 노드가 다운된 상태에서 여러명의 클라이언트가 동시에 락을 점유해도 되는 특수한 상황이 아니라면 사용할 수 없다.



싱글 인스턴스로 락을 구현하려고 할때 올바른 방법은 다음과 같다.

- 클라이언트가 리소스에 대한 락을 획득할 때, 해당 락의 value값을 임의의 값으로 지정해두고, 이 값을 기억한다.
- 어떤 클라이언트든 해당 락을 해제하기 위해서는 먼저 락의 value값을 해당 클라이언트가 알고 있는지 검사해야한다(문자열 매칭)
  - 락을 획득한 클라이언트만이 해당 값을 기억하고 있으므로, 그 클라이언트만 락을 풀 수 있게 된다.
- 이 때 임의 값은 random string이어도 좋고, 클라이언트 id와 timestamp를 조합한 방식으로 구현해도 좋다. 완벽하게 safe하지 않을수는 있지만, 대부분의 경우에 잘 동작할 것이다.

여기에 추가하여 key에 락 유효시간(lock validity time)을 두어 락을 점유한 후 일정 시간이 지나면 풀리도록 구현할 수 있다(일종의 TTL 개념).



이러한 방식은 레디스가 싱글 인스턴스인 상황에서는 잘 작동한다. 그러나 분산시스템에서는 조금 더 복잡한 과정을 거쳐야한다. 분산 시스템에서는 독립적인 Redis 노드가 N개 존재하기 때문이다.



## Redlock 알고리즘

레드락 알고리즘은 N개의 레디스 마스터가 있는 분산 환경일 때 락을 구현하기 위한 방식이다. 잠금을 획득하기 위해 위에서 설명했던 싱글 인스턴스 상황에서의 락 획득 방식을 조금 변형하여 사용한다.

1. 현재 시간을 밀리초 단위로 timestamp를 찍어 둔다.
2. 모든 인스턴스에서 동일한 키 및 임의 값을 사용하여 순차적으로 락을 획득하려고 시도한다. 이 때 각 인스턴스의 락 획득 제한 시간(timeout)은 락 유효시간에 비해 훨씬 더 적어야한다.
   - 락을 획득하는 시간동안 결국 다른 클라이언트의 요청은 제한되는 것이기 때문에, 이 시간은 최대한 줄여야한다.
   - 만약 다운된 노드가 하나라도 있다면, 락 획득 시간이 길어질 수 있으므로 최대한 빨리 다음 노드로 락 획득을 넘어가야 하기 때문.
3. 과반수의 락을 획득했고 이 때 락을 획득하는 총 시간(최종 시간 - 1번의 timestamp)이 락 유효시간보다 작으면 락을 획득한 것으로 간주한다.
4. 이 때 락 유효시간은 [디폴트 락 유효시간 - 락을 획득하는데 든 전체 경과 시간]이다.
5. 만약 분산 락을 획득하지 못했을 경우 락을 획득하지 못한 인스턴스를 포함하여 모든 인스턴스의 락을 해제한다.



이 알고리즘은 consistency, correctness가 보장되지 않는 허점을 가지고 있는데, [Designing Data-Intensive Applications(데이터 중심 애플리케이션 설계)](https://dataintensive.net/)를 쓴 마틴 클렙만이 [지적한 글](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)이 있다. 분산시스템에서 시간이 동기화되어있지 않다면 발생할 수 있는 문제인데, 이 문제를 해결하기 위해 fencing token을 발급하여 해결할 수 있다, 그 방식은 위의 글에 나와있으니 참고하자.

이 지적에 대해 [레드락 설계자가 반박한 글](http://antirez.com/news/101)도 있다.





### Retry on Failure

과반수의 락을 획득해야하는 레드락 알고리즘의 특성상 동일한 리소스에 대해 lock을 획득하려는 클라이언트들이 여럿 있으면 위험하므로, 이를 비동기화 하기 위해 요청이 실패할 시에 랜덤한 시간을 지연시키도록 구현해두어야한다(요청이 다시 동시에 몰리지 않도록 하기 위해서).



### 안전성 논란



### 생존성 논란



### 성능, 장애 복구 및 fsync



---



# Secondary Indexing

레디스는 key-value store처럼 보이지만, 실제로는 다양한 자료 구조를 지원하는 서버이므로 composite 인덱스 등을 포함하여 다양한 종류의 보조 인덱스를 생성할 수 있다.

몇가지 데이터 구조를 통해 레디스에서 보조 인덱스를 구현하는 방식에 대해 알아보자.

## sorted set의 숫자 인덱스

Redis에서 생성할 수 있는 가장 간단한 보조 인덱스 형태로, double precision float 형태의 score를 인덱스로 사용하는 것이다. 이때 오름차순으로 정렬된다.

score가 double precision의 float형태이기때문에, 순정 sorted set으로 구현할 수 있는 인덱싱 정밀도는 해당 수준에 한정된다.



## object ID와 연결한 인덱스 만들기

 
