# Patterns - Distributed Locks with Redis

생성일: 2022년 12월 18일 오후 2:04

> Redis를 사용한 분산 잠금 패턴
> 
- 서로 다른 프로세스가 상호 배타적인 방식으로 공유 리소스와 함께 작동해야하는 환경에서 유용
- 바닐라 단일 인스턴스 접근 방식보다 안전하다고 생각되는 DLM(분산 잠금 관리자)을 구현하는 Redlock이라는 알고리즘을 사용한다.

# 구현

- **[Redlock-py](https://github.com/SPSCommerce/redlock-py)** (Python implementation).
- **[Pottery](https://github.com/brainix/pottery#redlock)** (Python implementation).
- **[Redsync](https://github.com/go-redsync/redsync)** (Go implementation).
- **[Redisson](https://github.com/mrniko/redisson)** (Java implementation).
- **[node-redlock](https://github.com/mike-marcacci/node-redlock)** (NodeJS implementation). Includes support for lock extension.
- **[Deno DLM](https://github.com/oslabs-beta/Deno-Redlock)** (Deno implementation)

# Safety and Liveness Guarantees

- 분산 잠금을 효과적으로 사용하는 데 필요한 최소한의 세 가지 속성
    - 안전 속성: 상호 배제. 주어진 순간에 하나의 클라이언트만 잠금을 보유할 수 있음
    - 활성 속성 A:  교착상태 없음. 결국 리소스를 잠근 클라이언트가 충돌하거나 분할되더라도 항상 잠금을 획득할 수 있습니다.
    - 활성 속성B:  내결함성. 대부분의 Redis노드가 작동하는 한 클라이언트는 잠금을 획득하고 해제할 수 있다.

# ****Why Failover-based Implementations Are Not Enough****

> 장애조치 기반 구현이 충분하지 않은 이유
> 
- Redis를 이용해 리소스를 잠그는 가장 간단한 방법은 인스턴스에 키를 생성하는 것이다.
    - 키는 일반적으로 제한된 수명으로 생성되므로 결국 해제된다.
    - 클라이언트는 리소스를 해제해야 할 때 키를 삭제한다.
    - 표면적으로 잘 동작하지만 Redis master가 죽으면 복제본을 추가하지만 복제는 비동기식이므로 상호배제를 보장할 수 없음
    - 예: 이 모델에는 경쟁 조건이 있다.
        1. 클라이언트 A는 master에서 잠금을 획득한다.
        2. 키 쓰기가 복제본으로 전송되기 전에 마스터가 충돌한다.
        3. 복제본이 마스터로 승격된다.
        4. 클라이언트 B는 A가 이미 잠금을 보유하고 있는 동일한 리소스에 대한 잠금을 획득한다.
        → 안전 위반!

# Correct Implementation with a Single Instance

- 단일 인스턴스는 분산 알고리즘에 사용할 기반이다.
- 잠금을 획득하는 방법
    
    ```bash
    SET resource_name my_random_value NX PX 30000
    ```
    
    - 이 명령은 키가 아직 존재하지 않는 경우에만 키를 설정한다.(NX옵션)
    - 만료시간: 30000ms(PX옵션)
    - 키: “my_random_value”
        - 모든 클라이언트와 모든 잠금 요청에서 고유해야 한다.
- 기본적으로 임의의 값은 안전한 방법으로 잠금을 해제하기 위해 Redis에서 스크립트와 함께 사용된다.
    
    ```lua
    # Lua script
    if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1])
    else
        return 0
    end
    ```
    
    - 키가 존재하고 키에 저장된 값이 정확히 내가 기대하는 값인 경우에만 키를 제거해야 함
        - 다른 클라이언트에서 만든 잠금을 제거하지 않도록 하기 위해 중요
            - 클라이언트가 잠금을 획득 후 TTL보다 더 긴시간 동안 작업 수행이 차단될 수 있고, 나중에 다른 클라이언트가 이미 획득한 잠금을 제거할 수 있다.
            - DEL 명령만 사용하는 것은 클라이언트가 다른 클라이언트의 잠금을 제거할 수 있으므로 안전하지 않다.
            - 위 스크립트를 사용하면 모든 잠금이 임의의 문자열로 “서명”되므로 잠금을 제거하려는 클라이언트가 설정한 잠금인 경우에만 잠금이 제거됨
            - 이 임의의 문자열은 마이크로초 정밀도의 UNIX기반 timestamp를 사용한다.
    - 잠금 유효 시간은 키의 수명(자동 해제 시간)으로 사용되는 시간이다. 기술적으로 상호 배제 보장을 위반하지 않고 다른 클라이언트가 잠금을 다시 획득할 수 있기 전에 필요한 작업을 수행하기 위해 클라이언트가 가지고 있는 시간이다.
    - 이 시스템을 이용해 항상 사용 가능한 단일 인스턴스로 구성된 비분산 시스템에 대한 추론이 안전하다.

# The Redlock Algorithm

- 알고리즘 분산 버전에는 N개의 Redis master가 있다고 가정한다. 이러한 노드는 완전히 독립적이므로 복제 또는 기타 임시적 조정 시스템을 사용하지 않는다.
- 예: 각자 다른 가상머신(컴퓨터)에서 5개의 Redis 마스터를 실행하여 거의 독립적인 방식으로 실패하도록 해야한다. 잠금을 획득하기 위해 클라이언트는 다음 작업을 수행한다.
    1. 현재 시간을 밀리초 단위로 가져온다.
    2. 모든 인스턴스에서 동일한 키 이름과 임의의 값을 사용하여 모든 N 인스턴스에서 순차적으로 잠금을 획득하려고 시도한다. 2단계에서 각 인스턴스에 잠금을 설정할 때 클라이언트는 잠금을 획득하기 위해 총 잠금 자동 해제 시간에 비해 작은 시간을 사용한다. 이렇게 하면 클라이언트가 죽은 Redis 노드와 대화하려고 오랫동안 차단된 상태로 유지되는 것을 방지할 수 있다. 인스턴스를 사용할 수 없는 경우 최대한 빨리 다음 인스턴스와 대화를 시도해야한다.
    3. 클라이언트는 1단계에서 얻은 타임스탬프를 현재 시간에서 빼서 잠금을 획득하기 위해 경과한 시간을 계산한다. 클라이언트가 대부분의 인스턴스(최소 3개)에서 잠금을 획득할 수 있고 잠금을 획득하는 데 경과된 총 시간이 잠금 유효 시간보다 짧은 경우에만 잠금이 획득된 것으로 간주된다.
    4. (잠금이 획득된 경우 유효 시간) = (초기 유효 시간) - (3단계에서 계산된 경과 시간)
    5. 클라이언트가 어떤 이유로 잠금을 획득하지 못한 경우 (N/2+1 인스턴스를 잠금 수 없거나 유효 시간이 음수인 경우) 모든 인스턴스의 잠금을 해제하려고 시도한다. (잠글 수 없다고 믿었던 인스턴스도)

## Is the Algorithm Asynchronous?

- 이 알고리즘은 프로세스 간에 동기화된 시계가 없지만 모든 프로세스의 로컬시간이 거의 동일한 속도로 업데이트되며 잠금의 자동 해제 시간에 비해 약간에 오차가 있다는 가정에 의존한다.
    - 이 가정은 실제 컴퓨터와 유사하다. 모든 컴퓨터에는 로컬 시계가 있고, 일반적으로 작은 시계 드리프트를 갖기 위해 다른 컴퓨터에 의존할 수 있다.
- 이 시점에서 상호 배제 규칙을 더 잘 지정해야 한다.
    - 잠금을 보유한 잠금 유효시간에서 약간의 시간 내에 작업을 종료하는 한만 보장된다.

## Retry on Failure

- 클라이언트가 잠금을 획득할 수 없는 경우, 동일한 리소스에 대한 잠금을 동시에 획득하려는 여러 클라이언트를 비동기화하기 위해 무작위 지연 후 다시 시도해야한다. 이 때 아무도 승자가 없는 상태가 될 수 있다.
- 클라이언트가 대부분의 Redis인스턴스에서 잠금을 획득하려고 시도하는 속도가 빠를수록 브레인 분할 조건(및 재시도 필요성)에 대한 Window가 작아지므로 이상적으로는 클라이언트가 N 인스턴스들에 SET 명령을 전송하려고 동시에 멀티플렉싱을 이용해 시도해야한다.
- 대부분의 잠금을 획득하지 못한 클라이언트가 (부분적으로) 획득한 잠금을 최대한 빨리 해제하여 잠금을 다시 획득하기 위해 키 만료를 기다릴 필요가 없도록 하는 것은 정말 중요하다.
- 하지만 네트워크 파티션이 일어나고 클라이언트가 더 이상 Redis 인스턴스와 통신할 수 없는 경우 키 만료를 기다리면서 지불해야 하는 가용성 패널티가 있다.

## Releasing the Lock

- 잠금 해제는 간단하며 클라이언트가 주어진 인스턴스를 성공적으로 잠글 수 있는지 여부에 관계없이 수행할 수 있다.
- TTL을 기다려야한다.

## Safety Arguments

- 모든 인스턴스에는 동일한 수명을 가진 키가 포함된다. 키가 다른 시간에 설정되었으므로 키도 다른 시간에 만료된다. 첫 키가 시간 T1(첫 번째 서버에 연결하기 전에 샘플링한 시간)에 최악으로 설정되고, 마지막 키가 시간 T2(마지막 서버에서 응답을 얻은 시간)에 최악으로 설정되었다면 세트에서 만료되는 첫 번째 키는 최소한 `MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT` 동안 존재한다. 다른 모든 키는 나중에 만료되므로 적어도 이번에는 키가 동시에 설정될 것이라고 확신한다.
- 잠금을 획득한 경우 동시에 다시 획득할 수 없다.(상호 배타 속성 위반)
- 동시에 잠금을 획득하려는 여러 클라이언트가 동시에 성공할 수 없도록 해야한다.
- 클라이언트가 잠금 최대 유효 시간(기본적으로 SET에 사용하는 TTL)에 가깝거나 그보다 큰 시간을 사용해 대부분의 인스턴스를 잠근 경우 잠금이 유효하지 않은 것으로 간주하고 인스턴스의 잠금을 해제하므로 다음 사항 만 고려하면 된다.
    - 클라이언트가 유효 시간보다 짧은 시간에 대부분의 인스턴스를 잠글 수 있었던 경우. 위에서 이미 표현된 인수의 경우 MIN_VALIDITY의 경우 어떤 클라이언트도 잠금을 다시 획득할 수 없어야 한다.
    - 여러 클라이언트는 대부분을 잠그는 시간이 TTL 시간보다 커서 잠금이 무효화되는 경우에만 N/2+1 인스턴스를 동시에 잠글 수 있습니다("시간"은 2단계의 끝임).

## Liveness Arguments

- 시스템 활성도의 세가지 주요 기능
    - 잠금 자동 해제(키 만료 이후): 결국 키를 다시 잠글 수 있다.
    - 일반적으로 클라이언트가 잠금을 획득하지 못했거나 잠금을 획득하고 작업이 종료되었을 때 잠금을 제거하는 데 협력한다는 사실은 우리가 키를 다시 획득하기 위해 키가 만료될 때까지 기다릴 필요가 없다.
    - 클라이언트가 잠금을 재시도해야 할 때 대부분의 잠금을 획득하는 데 필요한 시간보다 비교적 긴 시간을 대기하여 리소스 경합 중에 스플릿 브레인 상태를 발생하지 않도록 합니다.
- 네트워크 파티션에서 TTL 시간과 동일한 가용성 페널티를 지불하므로 연속적인 파티션이 있는 경우 이 페널티를 무한정 지불할 수 있다. 이는 클라이언트가 잠금을 획득하고 잠금을 제거하기 전에 분할될 때마다 발생한다.
- 기본적으로 무한 연속 네트워크 파티션이 있는 경우 시스템을 무한정 사용할 수 없게 될 수 있다.

## ****Performance, Crash Recovery and fsync****

- 요구사항: Redis를 잠금 서버로 사용하는 많은 사용자는 잠금을 획득하고 해제하기 위한 대기 시간과 초당 수행할 수 있는 획득/해제 작업 수 모두에서 고성능을 필요로 합니다.
- 요구 사항을 충족하기 위해 N Redis 서버와 대화하여 대기 시간을 줄이는 전략은 Multiplexing(다중화)이다.(클라이언트와 각 인스턴스 간의 RTT가 유사하다고 가정하고 소켓을 비차단 모드로 설정하고 모든 명령을 보내고 나중에 모든 명령을 읽음)
- 충돌 복구 시스템 모델 대상 지속성에 관련된 고려사항
    - 지속성 없이 Redis를 구성하는 경우 잠금을 획득할 수 있는 인스턴스가 다시 시작되면 다른 클라이언트가 잠금의 독점성이라는 안전 속성을 위반해 다시 잠글 수 있다.
- AOF 지속성을 활성화하면 안전 속성을 지킬 수 있다.
    - SHUTDOWN 명령을 보내고 다시 시작하여 서버를 업그레이드 할 수 있다.
    - Redis 만료는 서버가 꺼져있어도 시간이 계속 경과되므로 요구사항이 적합하다.
    - 완전히 종료되어있을 때 모든 것이 정상이다.
    - 하지만 정전의 경우 Redis가 기본적으로 매초 디스크에서 fsync로 구성된 경우 재시작 후 키가 누락될 수 있다.
    - 이론적으로 어떤 종류의 인스턴스 재시작에도 불구하고 잠금 안전을 보장하려면 지속성 설정에서 fsync=always를 활성화해야 한다. 이것은 동기화 오버헤드로 인해 성능에 영향을 미친다.
    - 하지만 기본적으로 충돌 후 인스턴스가 재시작할 때 현재 활성 잠금에 더이상 참여하지 않는 한 알고리즘 안정성이 유지된다.
        - 즉, 인스턴스가 다시 시작될 때 현재 활성화된 잠금 세트는 모두 시스템에 다시 가입하는 인스턴스가 아닌 다른 인스턴스를 잠그면 확보된다.
- 이를 보장하기 위해 우리는 충돌 후 우리가 사용하는 최대 TTL 보다 최소한 더 사용할 수 없는 인스턴스를 만들어야한다. 인스턴스 충돌 시 존재했던 잠금에 대한 모든 키가 무효화되어 자동으로 해제되는 데 필요한 시간이다.
- 지연된 다시 시작을 사용하면 기본적으로 어떤 종류의 Redis지속성 없이도 안전을 보장할 수 있지만, 이는 가용성 패널티로 해석될 수 있다. 예를 들어 대부분의 인스턴스가 충돌하는 경우 시스템은 TTL에 대해 전역적으로 사용할 수 없게 된다.

## Making the algorithm more reliable: Extending the lock

- 클라이언트가 수행하는 작업이 작은 단계로 구성된 경우 기본적으로 더 작은 잠금 유효 시간을 사용하고 잠금 확장 메커니즘을 구현하는 알고리즘을 확장할 수 있다.
- 클라이언트는 잠금을 대부분의 인스턴스로 확장할 수 있고 유효 시간 내에 잠금을 다시 획득한 것으로 간주해야 한다.(기본적으로 사용할 알고리즘은 잠금을 획득할 때 사용된 알고리즘과 매우 유사함).
- 기술적으로 알고리즘을 변경하지 않으므로 활동성 속성을 위반하지 않기 위해 최대 잠금 재획득 시도 횟수를 제한해야 한다.

## Disclaimer about consistency

> 일관성에 의한 면책조항
> 
- 펜싱 토큰을 구현해야 합니다. 이는 상당한 시간이 소요될 수 있고 모든 분산 잠금 시스템에 적용되는 프로세스에 특히 중요합니다. 잠금의 수명을 연장하는 것도 옵션이지만 잠금을 획득한 프로세스가 살아있는 한 잠금이 유지된다고 가정하지 마십시오.
- Redis는 TTL 만료 메커니즘에 단조로운 시계를 사용하지 않는다. 이는 벽시계 이동으로 인해 둘 이상의 프로세스에서 잠금을 획득할 수 있음을 의미합니다. 관리자가 수동으로 서버의 시간을 설정하고 NTP를 적절하게 설정하는 것을 방지하여 문제를 완화할 수 있지만 이 문제가 실생활에서 발생하고 일관성이 손상될 가능성은 여전히 있습니다.