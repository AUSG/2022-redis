# Using Redis

> https://redis.io/docs/manual/

## Client-side caching in Redis

- 애플리케이션의 메모리에 캐시의 일부 데이터를 저장하는 기술.
- 장점
  - 매우 빠르게 데이터를 가져올 수 있고,
  - 노드가 더 적은 쿼리와 요청을 받으므로, 더 적은 노드로 운영할 수 있다.

###### There are two hard problems in computer science...

- 어떻게 데이터를 제 때 갱신할 수 있을 것인가?
- 애플리케이션에 따라 이 문제가 아주 중요하지는 않은 경우, TTL을 설정한다.
- 또는 Redis Pub/Sub을 이용해 클라이언트에 invalidation 메시지를 보낼 수 있다.
  - 하지만 메모리에 데이터를 들고 있지 않은 클라이언트도 요청을 받아야 해서, 대역폭의 관점에서 다소 비효율적임.
  - 데이터를 변경할 때마다 Pub 해야 하므로 CPU 시간도 더 걸림.

###### The Redis implementation of client-side caching

- Redis의 client-side 캐시 지원은 `Tracking`이라고 부른다.
  - default mode: 서버는 클라이언트가 접근한 키를 기억하고, 해당 키가 수정되면 invalidation 메시지를 보낸다. 서버의 메모리 비용은 많이 들지만, 필요한 클라이언트에게만 invalidation 메시지를 보낼 수 있어 효율적임.
  - broadcasting mode: 클라이언트는 key prefix (ex. `object:`) 를 명시적으로 구독하고, 해당 키들이 수정되는 경우 알림을 받는다.
- 하지만 매우 많은 클라이언트가 매우 많은 키를 요청하는 경우, Redis 서버의 CPU, 메모리는 버거워질 수 있다.
  - 서버는 단일 전역 테이블 `Invalidation Table` 에 클라이언트 목록을 저장한다.
  - 새로운 키가 추가될 때 테이블의 개수 제한을 넘어가면, 클라이언트에게 invalidation 메시지를 보낸 후 이전 항목을 테이블에서 지워 리소스를 절약할 수 있다.
  - Invalidation Table은 클라이언트가 연결을 끊을 때 GC를 실행하기 위해, 포인터를 저장하는 대신 클라이언트 ID를 저장한다.

###### Two connections mode

- Redis 6의 새로운 프로토콜인 RESP3을 이용하면 하나의 connection에서 데이터 쿼리도 실행하고 invalidation 메시지도 받을 수 있다.
- 하지만 connection을 나눠서 구현하고 싶을 수 있다. 이 경우 client id를 지정해 invalidation 메시지는 다른 연결로 redirect 되도록 구성할 수 있다.
  - RESP2에서도 Two connections mode는 사용할 수 있다.

###### What tracking tracks

1. 애플리케이션에서 새로운 객체를 생성할 때 많은 것들을 캐시하는 경우 더 효율적임.
2. 서버는 클라이언트 키에 대한 더 많은 데이터를 저장해야 함.
3. 클라이언트는 실제로 캐시하지 않은 키에 대한 invalidation 메시지를 받을 수도 있음.

###### Opt-in caching

- 클라이언트가 실제로 캐시한 키만 서버에 명시적으로 전달하고 싶을 수도 있음.
- 이 경우, 새로 캐시할 때 더 많은 대역폭을 사용하지만, 서버의 저장소 비용과 클라이언트가 받는 invalidation 메시지의 수를 줄일 수 있음.

```sh
CLIENT TRACKING on REDIRECT 1234 OPTIN
```

- 그리고 아래처럼 실제 커맨드를 날리기 직전에 이런 명령을 보내야 한다.

```sh
CLIENT CACHING YES
GET foo
```

###### Broadcasting mode

- 서버는 Invalidation Table에 아무 것도 저장하지 않고, Prefixes Table을 이용해 클라이언트마다 구독하는 prefix를 저장한다.
- 서버는 등록된 prefix 수에 비례해 CPU를 사용한다. prefix 수가 늘어나면 CPU 비용이 꽤 커질 수도 있음.

###### The NOLOOP option

- 값을 쓰는 것이 곧 키의 변경이라 다시 invalidation 메시지로 받아 로컬 메모리의 캐시가 날아가버릴 수 있다.
- `NOLOOP` 옵션을 사용하면 키를 쓴 클라이언트는 invalidation 메시지를 발송할 대상에서 제외할 수 있다.

###### Avoiding race conditions

- 클라이언트가 GET을 보내는 동안 다른 connection으로 invalidation 메시지를 먼저 받아버릴 수 있다.
- GET을 보내기 전에 key를 백업하고, 응답을 받아 다시 캐시에 저장할 때 key 값을 비교하고 값이 다르면 저장하지 않는 그런 로직이 필요함.
- RESP3을 이용해 하나의 connection만 사용하면 순서가 보장되므로 이런 케이스는 발생하지 않음.

###### What to do when losing connection with the server

- connection이 끊어지면 로컬 캐시를 flush 해야 함.
- invalidation connection으로 주기적으로 ping을 보내 connection 활성화 여부를 주기적으로 확인해야 함.

###### What to cache

- 계속 변경되는 많은 키는 적절하지 않음.
- 아주 드물게 변경되는 많은 키는 적절하지 않음.
- 자주 요청되고, 적절히 자주 변경되는 키가 좋음.

###### note

- [redis-py](https://github.com/redis/redis-py/blob/6219574b042a6596b150ca8248441198f01f8c87/redis/commands/core.py#L616)도 구현되어 있다. (오예)
  - redis-py는 RESP3를 애초에 지원하지 않고 있고, RESP2만 이용 가능함.
  - Invalidation 메시지는 Redis Pub/Sub으로 따로 받아야 하는 아쉬움.
- Opt-in caching을 보면서, 서버에 저장된 Invalidation Table의 클라이언트 키를 명시적으로 삭제해줄 수는 없을까하는 생각을 함.

## Redis pipelining

- 한 번에 여러 명령을 보내고 받아 성능을 개선할 수 있다.

###### Redis Pipelining

- 클라이언트가 아직 응답을 받기 전에 다음 요청을 처리할 수 있다. 이를 통해 응답을 기다리지 않고 여러 요청을 보내고, 한 번에 응답을 읽을 수 있다.

###### It's not just a matter of RTT

- RTT만의 개선이 아닌, Redis 서버의 초당 실행할 수 있는 operation 수도 개선할 수 있다. (socket I/O의 개선)

## Redis keyspace notifications

- Redis 데이터의 변경 사항을 Redis Pub/Sub 채널로 구독할 수 있다.
- 수신할 수 있는 이벤트:
  - 해당 키에 영향을 주는 모든 명령.
  - LPUSH.
  - 데이터베이스 0에서 만료되는 키.

###### Events generated by different commands

- 키가 실제로 수정된 경우에만 이벤트가 생성됨. 존재하지 않는 요소를 Set에서 삭제하거나 하는 경우엔 이벤트가 생성되지 않음. (굿!)

###### Timing of expired events

- Redis는 TTL을 아래와 같이 처리함.
  - 키를 접근했는데, 만료된 것으로 확인되는 경우 만료됨.
  - 접근할 일이 없는 키인 경우, 백그라운드 프로세스에서 주기적으로 키를 찾아 만료시킴.
- 따라서 TTl이 걸려있어도 즉시 expired 이벤트가 생성된다는 보장은 없다.

###### note

- Database 0이 무엇일까? `# TODO`

## Redis Pub/Sub

- Publisher는 Subscriber가 누군지 알 수 없고, 채널로 메시지를 보내게 됨.
- Subscriber는 Publisher가 누군지 알 수 없고, 선택한 채널(들)에서 메시지를 받게 됨.

###### Format of pushed messages

- `subscribe`: 채널을 성공적으로 구독했음을 의미함. reply의 2번째 요소는 채널을 의미.
- `unsubscribe`: 채널을 성공적으로 구독 취소했음을 의미함. reply의 2번째 요소는 채널 이름, 3번째 요소는 현재 구독 중인 채널 수를 의미.
- `message`: 다른 클라이언트가 `PUBLISH`한 메시지. reply의 2번째 요소는 채널 이름, 3번째 요소는 메시지 페이로드임.

###### Database & Scoping

- 범위 지정이 필요하면 prefix를 붙일 수 있음.

###### Pattern-matching subscriptions

- 구독할 채널 이름으로 패턴 매칭을 지원하는데, Glob 패턴임. (ex. `news.*`)
- `SUBSCRIBE foo`와 `PSUBSCRIBE f*`을 같이 하면 동일한 메시지를 여러 번 받게 됨. (`subscribe`, `psubscribe`)

###### note

- Pattern-matching subscriptions에서, 나중에 추가된 채널도 Glob 패턴에 걸리면 메시지를 수신할 수 있을까? `# TODO`

## Transactions

- 트랜잭션의 모든 명령은 직렬화되어 순차 실행된다. 다른 클라이언트의 요청은 Redis 트랜잭션 중에 절대 처리되지 않음.
- `EXEC` 커맨드는 트랜잭션의 모든 명령을 트리거 하는데, 그 전에 connection이 끊어지면 아무 것도 일어나지 않는다.
  - `append-only` 파일은 한 번의 write(2) syscall로 디스크에 write 한다.
  - Redis 서버가 갑자기 중단되는 경우, 일부 명령어만 등록된 상태로 남을 수 있는데, Redis 서버가 다시 시작될 때 이러한 상태를 탐지하고 오류와 함께 종료된다. `redis-check-aof`를 사용하면 `append-only` 파일을 고칠 수 있다.

###### Usage

- `MULTI` 커맨드를 이용해 트랜잭션을 시작하고,
- 이후 입려되는 명령어는 바로 실행되지 않고 queue에 넣는다.
- `EXEC` 커맨드를 실행하면 모든 명령이 실행된다.
  - 실행된 명령어 순서대로 응답을 배열로 반환한다.
- `DISCARD` 커맨드를 실행하면 queue를 비우고 트랜잭션이 종료된다.

###### Errors inside a transaction

- `EXEC` 명령이 호출되기 전, queue에 들어가는 중에 실패할 수 있다. (명령이 잘못된 구문이거나, 메모리가 부족한 경우 등)
- `EXEC` 명령이 호출되었는데 key의 타입이 잘못되었거나 하는 이유로 실패할 수 있다.
- 트랜잭션 도중에 명령이 실패하더라도, 남은 명령은 계속 처리된다. (`# TODO` 롤백이 지원되지 않기 때문일까?)

###### What about rollbacks?

- 단순함과 성능에 영향이 있어 롤백은 지원하지 않음.

###### Optimistic locking using check-and-set

- `WATCH` 명령어를 이용해 check-and-set (CAS)을 구현할 수 있다.
- `WATCH`ed 된 키들은 모니터링 되며 변경 사항이 감지됨. `EXEC` 하기 전에 키가 변경되면 트랜잭션이 중단된다.
- 이를 통래 `WATCH`와 `EXEC` 사이에 다른 클라이언트가 값을 변경하는 것을 감지할 수 있다.
- 일반적으로 여러 클라이언트가 동일한 키에 접근하는 경우는 많이 없는 편이므로, 명령을 다시 실행해야 하는 경우는 드문 편이다.
