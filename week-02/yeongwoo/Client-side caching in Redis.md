# Client-side caching in Redis

생성일: 2022년 12월 3일 오후 8:04

> 레디스에서 서버 지원, 클라이언트 측 캐싱
> 
- Client-side 캐싱은 고성능 서비스를 만드는데 사용되는 기술
- 애플리케이션 서버가 데이터베이스에 접근하는 방법
    
    ```bash
    +-------------+                                +----------+
    |             | ------- GET user:1234 -------> |          |
    | Application |                                | Database |
    |             | <---- username = Alice ------- |          |
    +-------------+                                +----------+
    ```
    
- client-side 캐싱 사용법
    - 자주 호출되는 쿼리의 응답을 애플리케이션 메모리에 직접 저장해 데이터베이스를 접근하지 않고 재사용 가능
    
    ```bash
    +-------------+                                +----------+
    |             |                                |          |
    | Application |       ( No chat needed )       | Database |
    |             |                                |          |
    +-------------+                                +----------+
    | Local cache |
    |             |
    | user:1234 = |
    | username    |
    | Alice       |
    +-------------+
    ```
    
    - 장점
        - 데이터베이스 액세스 시간보다 훨씬 소요시간이 적음
        - 데이터베이스의 부하를 크게 줄임
    - 항목이 드물게 바뀌는 데이터 세트를 캐싱하는 것이 유용함(최근 게시물 목록)

---

# There are two hard problems in computer sience…

- client-side 캐싱의 문제점은 애플리케이션이 보유하고 있는 정보를 무효화/업데이트 하는 방법이 부족하다.
- 캐시된 정보에 대해서 업데이트를 해주기 위해 ttl(time to live)를 정해줄 수 있다.
- Pub/Sub 패턴에서는 Subscribe 클라이언트에게 무효화 메시지를 보낸다.
    - 사용된 대역폭의 관점에서 까다롭고 비용이 많이 든다.
    - 특정 클라이언트가 무효화된 데이터의 복사본이 없더라도 애플리케이션의 모든 클라이언트에 무효화 메시지를 보내기 때문
    - 데이터를 변경하는 모든 애플리케이션 쿼리는 “PUBLISH” 명령을 사용해야 하고, 데이터베이스에서 이 명령을 처리하는 데 더 많은 CPU 시간을 소모한다.

---

# The Redis implementation of client-side caching

Redis client-side 캐싱지원을 추적(Tracking)이라고 불리며, 두가지 모드가 있다.

## default mode(기본모드)

서버는 클라이언트가 액세스한 키를 기억하고 동일한 키가 수정될 때 무효화 메시지를 보낸다.

- 서버측의 메모리 비용이 소모된다.
- 클라이언트가 메모리에 있을 수 있는 키 set에 대해서만 무효화 메시지를 보낸다.
- 과정
    1. 클라이언트는 원하는 경우 추적을 활성화할 수 있다. 연결이 시작된다.
    2. 추적이 활성화되면 서버는 클라이언트가 연결 수명동안 요청한 키를 기억한다. (이런 키들에 대한 읽기 명령을 전송함으로써)
    3. 키가 일부 클라이언트에 의해 수정되거나 만료되거나, maxmemory정책에 의해 퇴거되면, 키가 캐시될 수 있는 추적이 활성화 된 모든 클라이언트는 무효화 메시지로 알림을 받는다.
    4. 클라이언트가 무효화 메시지를 받으면 오래된 데이터를 제공하지 않기위해 해당 키를 제거해야한다.
- 수십개의 많은 클라이언트가 있고, 수백개의 키를 저장해야한다면 서버는 너무 많은 정보를 저장하게 된다. 결국 서버측의 메모리의 양과 기능을 구현하는 데이터구조를 처리하는 CPU비용을 제한하기 위해 두 가지 방법을 사용한다.
    - 서버는 주어진 키를 단일 전역 테이블(무효화 테이블-Invalidation Table)에 캐시했을 수 있는 클라이언트 목록을 기억한다. 무효화 테이블에는 최대 항목 수가 포함된다. 새 키가 삽입되면 서버는 키가 수정된 척 하고 클라이언트에게 무효화 메시지를 보내 오래된 항목을 제거한다. 그렇게 함으로써 클라이언트가 키의 로컬 복사본을 가지고 있는 클라이언트가 그것을 제거하도록 강요하더라도, 이 키에 사용된 메모리를 회수할 수 있다.
    - 무효화 테이블 안에는 클라이언트의 구조에 대한 포인터를 저장할 필요가 없으며, 이는 클라이언트가 연결을 끊을 때 가비지 수집 절차를 강제한다. 대신 클라이언트 ID를 저장한다.
    - 데이터베이스 번호로 나누지 않고 단일 키 네임스페이스가 있다. 여러 데이터베이스에 상관없이 키 네임스페이스가 변경되면 상관없이 무효화 메시지가 전송된다.

## broadcasting mode(방송모드)

서버는 클라이언트가 액세스한 키를 기억하지 않는다.

- 서버측의 메모리를 전혀 사용하지 않는다.
- 클라이언트는 `object:` 또는 `user:`같은 키를 구독하고, 구독된 접두사와 일치하는 키를 건드릴 때마다 알림 메시지를 받는다.

---

# Two connections mode

- redis 6에서 지원하는 RESP3(프로토콜)을 사용하면 데이터쿼리 결과와 무효화 메시지를 한 연결에서 받을 수 있음
- 그러나 클라이언트에서는 두개의 분리된 연결에서 캐싱을 구현하는 것을 선호할 수 있음
- 클라이언트가 추적을 활성화하면 다른 연결의 “클라이언트 ID”를 지정하여 무효화 메시지를 다른 연결로 리디렉션하도록 지정가능함
- 많은 데이터 연결은 무효화 메시지를 동일한 연결로 리디렉션할 수 있고, 연결 풀링을 구현하는 클라이언트에게 유용하다.
- RESP2에서도 지원하는 유일한 모델
- 시작
    - 클라이언트는 무효화에 사용될 첫 번째 연결을 열고, 연결 ID를 요청하고, RESP2 모드에서 무효화 메시지를 받는 데 사용되는 특수 채널에 Pub/Sub을 통해 구독한다.
    
    ```bash
    (Connection 1 -- used for invalidations)
    CLIENT ID
    :4
    SUBSCRIBE __redis__:invalidate
    *3
    $9
    subscribe
    $20
    __redis__:invalidate
    :1
    
    # 데이터 연결에서 추적을 활성화 할 수 있음
    (Connection 2 -- data connection)
    CLIENT TRACKING on REDIRECT 4
    +OK
    
    GET foo
    $3
    bar
    
    # 클라이언트는 로컬 메모리에 "foo" => "bar"를 캐시하기로 결정할 수 있다.
    # 이제 다른 클라이언트가 "foo" 키의 값을 수정한다.
    (Some other unrelated connection)
    SET foo bar
    +OK
    
    # 결과적으로 무효화 연결은 지정된 키를 무효화하는 메시지를 받게 된다.
    (Connection 1 -- used for invalidations)
    *3
    $7
    message
    $20
    __redis__:invalidate
    *1
    $3
    foo
    ```
    
    - 클라이언트는 이 캐싱 슬롯에 캐시된 키가 있는지 확인하고 더 이상 유효하지 않은 정보를 제거한다.
    - Pub/Sub메시지의 세 번째 요소는 단일 키가 아니라 단일 요소가 있는 무효화할 키배열이다.
    - 플러시(FLUSHALL or FLUSHDB)의 경우 null이 전송
    - Pub/Sub을 사용하는 것은 “이전 클라이언트 구현을 재사용하기 위한 트릭”이다.
    - 모든 클라이언트가 수신하는 것이 아닌, CLIENT명령의 REDIRECT인수에 지정된 연결만 메시지를 수신가능하다.

---

# What tracking tracks

- 캐싱된 키는 서버에서 추적하기 때문에 클라이언트는 어떤 키를 캐싱하는지 서버에 알릴 필요가 없다.
- 검색된 새 데이터를 캐시하고 가장 오래된 캐시된 개체를 버릴 수 있다.
- 서버의 추적 tradeoff
    - 클라이언트가 새 객체를 환영하는 정책으로 많은 것을 캐시하는 경향이 있을 때 더 효율적이다.
    - 서버는 클라이언트 키에 대한 더 많은 데이터를 유지해야 한다.
    - 클라이언트는 캐시하지 않은 개체에 대한 불필요한 무효화 메시지를 받는다.

---

# Opt-in caching

- 클라이언트는 선택한 키만 캐시하고 캐시할 항목과 캐시하지 않을 항목을 서버에 명시적으로 전달하고 싶어할 수도 있음.
    - 장점: 서버가 기억해야 하는 데이터의 양과 클라이언트가 받는 무효화 메시지의 양이 감소함
    - 단점: 새 개체를 캐싱할 때 더 많은 대역폭을 필요로 함
- OPTIN 옵션을 이용해 tracking을 활성화해야한다
    
    ```bash
    CLIENT TRACKING on REDIRECT 1234 OPTIN
    ```
    
- 기본적으로 읽기 쿼리에 언급된 키는 캐시되지 않는다.
- 클라이언트가 캐시하려고 할 때, 데이터를 검색하기 위한 실제 명령 직전에 특수 명령어를 보내야한다.
    
    ```bash
    CLIENT CACHING YES
    +OK
    GET foo
    "bar"
    ```
    
- CACHING 명령어: 직후 실행되는 명령에 영향을 줌. 이후 MULTI 명령이 추가될 경우 트랜잭션의 모든 명령이 추적됨
- Lua 스크립트의 경우 스크립트에 의해 실행되는 모든 명령이 추적된다.

---

# Broadcasting mode

- 클라이언트는 PREFIX옵션을 사용해 하나 이상의 접두사를 사용해 BCAST 옵션을 이용해 클라이언트 캐싱을 활성화 한다.
    - 예
        
        ```bash
        CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:
        ```
        
    - 접두사가 지정되지 않은 경우 빈 문자열로 간주되므로, 클라이언트는 수정되는 모든 키에 대해서 무효화 메시지를 받게 됨.
    - 하나 이상의 접두사가 지정된 경우, 지정된 접두사 중 하나와 일치하는 키만 무효화 메시지로 전송된다.
- 서버는 무효화 테이블에 아무 것도 저장하지 않는다.
    - 대신 각 접두사가 클라이언트 목록에 연결되는 다른 접두사 테이블을 사용한다.
- 두 접두사는 키 스페이스의 겹치는 부분을 추적할 수 없다.
- 접두사와 일치하는 키가 수정될 때마다 해당 접두사를 구독하는 모든 클라이언트는 무효화 메시지를 받게 된다.
- 서버는 등록된 접두사 수에 비례해 CPU를 사용한다. 많은 수의 접두사를 사용하면 CPU 비용이 상당히 커진다.
- 서버는 주어진 접두사에 가입한 모든 클라이언트에 대해 단일 회신을 생성하는 최적화를 수행하고 모두에게 동일한 회신을 보낼 수 있다. 이는 CPU 사용량을 낮추는데 도움이 된다.

---

# The NOLOOP option

- 기본적으로 클라이언트 추적은 키를 수정한 클라이언트에 무효화 메시지를 보낸다.
    - 클라이언트는 쓰기를 로컬로 자동 캐싱하지 않는 매우 기본적인 논리를 구현하기 때문에 이것을 원한다.
- 고급 클라이언트는 로컬 메모리 내 테이블에서 수행하는 쓰기 작업도 캐시하려고 할 수 있다.
    - 이 경우 쓰기 직후에 무효화 메시지를 받는 것은 클라이언트가 방금 캐시한 값을 강제로 제거하도록 하기 때문에 문제가 됨.
- NOLOOP option
    - 고급 클라이언트의 경우에 유용
    - default mode와 broadcast mode에서 사용 가능
    - 사용시 클라이언트는 자신이 수정한 키에 대한 무효화 메시지를 받고싶지 않다고 서버에 알릴 수 있음

---

# Avoiding race conditions

- 무효화 메시지를 다른 연결로 리디렉션 하는 클라이언트 쪽 캐싱을 구현할 때 경쟁 상태가 발생할 수 있음.
    
    ```bash
    # 데이터 연결: D / 무효화 연결: I 호출
    [D] client -> server: GET foo
    [I] server -> client: Invalidate foo (somebody else touched it)
    [D] server -> client: "bar" (the reply of "GET foo")
    ```
    
    - GET에 대한 응답이 클라이언트에 도달하는데 더 느림
        - 더이상 유효하지 않은 실제 데이터보다 먼저 유효화 메시지 수신됨
        - 오래된 버전의 foo 를 계속 제공 될 예정
- 위 문제를 방지하기 위해 자리 표시자와 함께 명령을 보내며 캐시를 채우는 것이 좋음
    
    ```bash
    Client cache: set the local copy of "foo" to "caching-in-progress"
    [D] client-> server: GET foo.
    [I] server -> client: Invalidate foo (somebody else touched it)
    Client cache: delete "foo" from the local cache.
    [D] server -> client: "bar" (the reply of "GET foo")
    Client cache: don't set "bar" since the entry for "foo" is missing.
    ```
    
- 이 경쟁 조건은 데이터 및 무효화 메시지의 단일 연결을 사용할 때 가능하지 않음.
    - 이 경우 메시지의 순소는 항상 알려져있기 때문

---

# ****What to do when losing connection with the server****

- 무효화 메시지를 받기 위해 사용하는 소켓과의 연결이 끊어지면 오래된 데이터로 끝날 수 있음
- 해결 방법
    1. 연결이 끊어지면 로컬 캐시가 flush 되는지 확인
    2. Pub/Sub 또는 RESP3와 함께 RESP2를 사용하는 경우 무효화 채널을 주기적으로 ping함
        - 연결이 끊어진 것처럼 보이는 경우 최대 시간이 지나고 연결을 닫고 캐시를 flush한다.

---

# ****What to cache****

- 캐시된 키가 실제 요청에서 제공된 횟수에 대한 내부 통계를 원할 수 있음
    - 지속적으로 변경되는 많은 키를 캐시하고 싶지 않기 때문에
    - 매우 드물게 요청되는 많은 키를 캐시하고 싶지 않기 때문에
    - 자주 요청되고 적당한 속도로 변경되는 키를 캐시하고 싶기 때문에
- 더 간단한 클라이언트는 최근에 제공되지 않은 키를 제거하려고 시도하며 캐시된 값이 제공된 마지막 시간을 기억하는 임의 샘플링을 사용하여 데이터 제거 가능

---

# ****Other hints for implementing client libraries****

- TTL 처리: TTL로 키 캐싱을 지원하려면 키 TTL과 로컬캐시 TTL을 설정해야 한다.
- TTL이 없더라도 모든 키에 최대 TTL을 설정하는 편이 좋음
- 클라이언트가 사용하는 메모리 양을 제한하는 것이 절대적으로 필요 (새 키가 추가될 때 이전 키를 제거하는 방법이 있어야 한다.)

---

# ****Limiting the amount of memory used by Redis****

- Redis가 기억하는 최대 키 수에 적합한 값을 구성하거나 메모리를 사용하지 않는 방송모드를 사용할 것.
- 기본 모드일 경우 소비되는 메모리는 추적되는 키 수와 해당키를 요청하는 클라이언트 수에 비례한다.